#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <sodium.h>
#include "imc_crypto.h"

// Parameters for generating a secret key
static const char IMC_SALT[crypto_pwhash_SALTBYTES+1] = "imageconceal2023";
static bool IS_LITTLE_ENDIAN = true;

// Parameters of the Blum Blum Shub algorithm (pseudorandom number generator)
// The primes are: 
//   - congruent to 3 (mod 4)  (have a remainder of 3 when divided by 4)
//   - are safe (can be written as 2p + 1, where p is also prime)
//   - fit a 16-bit unsigned integer
// The seed will be chosen in order to fit a 32-bit unsigned integer,
// which ensures that it won't overflow when squared.
static const uint64_t PRIME_1 = 65267UL;
static const uint64_t PRIME_2 = 65147UL;
static const uint64_t BBS_MOD = PRIME_1 * PRIME_2;

// Generate a secret key from a password
int imc_crypto_context_create(char *password, CryptoContext **out)
{
    // Verify whether the system is little or big endian
    static bool endianness_test = false;
    if (!endianness_test)
    {
        const uint16_t val = 1;
        const uint8_t *bytes = (uint8_t *)(&val);
        IS_LITTLE_ENDIAN = bytes[0] == 1 ? true : false;
        endianness_test = true;
    }
    
    // Storage for the secret key and the seed of the number generator
    CryptoContext *context = sodium_malloc(sizeof(CryptoContext));
    sodium_memzero(context, sizeof(CryptoContext));
    if (!context) return IMC_ERR_NO_MEMORY;
    
    // Storage for the password hash
    // Note: Only the lower half of the seed bytes will be filled,
    //       in order to ensure it will not overflow when squared.
    const size_t key_size = sizeof(context->xcc20_key);
    const size_t seed_size = sizeof(context->bbs_seed) / 2;
    const size_t out_len = key_size + seed_size;
    uint8_t output[out_len];
    sodium_mlock(output, sizeof(output));
    
    do
    {
        // Password hashing: generate enough bytes for both the key and the seed
        int status = crypto_pwhash(
            (uint8_t * const)&output,
            sizeof(output),
            password,
            strlen(password),
            IMC_SALT,
            IMC_OPSLIMIT,
            IMC_MEMLIMIT,
            crypto_pwhash_ALG_ARGON2ID13
        );
        if (status < 0) return IMC_ERR_NO_MEMORY;

        // The lower bytes are used for the key (32 bytes)
        memcpy(&context->xcc20_key, &output[0], key_size);

        // The upper bytes are used for the seed (64-bit unsigned integer)
        if (IS_LITTLE_ENDIAN)
        {
            memcpy(&context->bbs_seed, &output[key_size], seed_size);
        }
        else
        {
            uint8_t *seed_buffer = (uint8_t *)(&context->bbs_seed);
            for (size_t i = 0; i < seed_size; i++)
            {
                seed_buffer[i] = output[out_len - 1 - i];
            }
        }
    } while (
        // Check if the generated seed meets the requirements of the Blum Blum Shub algorithm
        // (all the bellow checks must evaluate to false)
           context->bbs_seed % PRIME_1 == 0
        || context->bbs_seed % PRIME_2 == 0
        || context->bbs_seed <= 1
    );
    
    // Release the unecessary memory and store the output
    sodium_munlock(output, sizeof(output));
    *out = context;

    return IMC_SUCCESS;
}

// Pseudorandom number generator using the Blum Blum Shub algorithm
// It writes a given amount of bytes to the output, while taking into account the endianness of the system.
void imc_crypto_prng(CryptoContext *state, size_t num_bytes, uint8_t *output)
{
    // Bitmasks
    static const uint8_t bit[8] = {1, 2, 4, 8, 16, 32, 64, 128};
    
    for (size_t i = 0; i < num_bytes; i++)
    {
        // Fill a byte with random bits
        uint8_t byte = 0;
        for (size_t j = 0; j < 8; j++)
        {
            // Take the least significant bit of each iteration
            state->bbs_seed = (state->bbs_seed * state->bbs_seed) % BBS_MOD;
            if (state->bbs_seed & 1) byte |= bit[j];
        }

        // Fill the output with the generated bytes
        if (IS_LITTLE_ENDIAN)
        {
            output[i] = byte;
        }
        else
        {
            output[num_bytes - 1 - i] = byte;
        }
    }
}